/* automatically generated by rust-bindgen */

pub const _ERRNO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _BSD_SOURCE: u32 = 1;
pub const _SVID_SOURCE: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_BSD: u32 = 1;
pub const __USE_SVID: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201103;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 19;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const _FCNTL_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const __O_LARGEFILE: u32 = 0;
pub const F_GETLK64: u32 = 5;
pub const F_SETLK64: u32 = 6;
pub const F_SETLKW64: u32 = 7;
pub const O_ACCMODE: u32 = 3;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_CREAT: u32 = 64;
pub const O_EXCL: u32 = 128;
pub const O_NOCTTY: u32 = 256;
pub const O_TRUNC: u32 = 512;
pub const O_APPEND: u32 = 1024;
pub const O_NONBLOCK: u32 = 2048;
pub const O_NDELAY: u32 = 2048;
pub const O_SYNC: u32 = 1052672;
pub const O_FSYNC: u32 = 1052672;
pub const O_ASYNC: u32 = 8192;
pub const __O_DIRECTORY: u32 = 65536;
pub const __O_NOFOLLOW: u32 = 131072;
pub const __O_CLOEXEC: u32 = 524288;
pub const __O_DIRECT: u32 = 16384;
pub const __O_NOATIME: u32 = 262144;
pub const __O_PATH: u32 = 2097152;
pub const __O_DSYNC: u32 = 4096;
pub const __O_TMPFILE: u32 = 4259840;
pub const F_GETLK: u32 = 5;
pub const F_SETLK: u32 = 6;
pub const F_SETLKW: u32 = 7;
pub const O_DIRECTORY: u32 = 65536;
pub const O_NOFOLLOW: u32 = 131072;
pub const O_CLOEXEC: u32 = 524288;
pub const O_DSYNC: u32 = 4096;
pub const O_RSYNC: u32 = 1052672;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const __F_SETOWN: u32 = 8;
pub const __F_GETOWN: u32 = 9;
pub const F_SETOWN: u32 = 8;
pub const F_GETOWN: u32 = 9;
pub const __F_SETSIG: u32 = 10;
pub const __F_GETSIG: u32 = 11;
pub const __F_SETOWN_EX: u32 = 15;
pub const __F_GETOWN_EX: u32 = 16;
pub const F_DUPFD_CLOEXEC: u32 = 1030;
pub const FD_CLOEXEC: u32 = 1;
pub const F_RDLCK: u32 = 0;
pub const F_WRLCK: u32 = 1;
pub const F_UNLCK: u32 = 2;
pub const F_EXLCK: u32 = 4;
pub const F_SHLCK: u32 = 8;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const FAPPEND: u32 = 1024;
pub const FFSYNC: u32 = 1052672;
pub const FASYNC: u32 = 8192;
pub const FNONBLOCK: u32 = 2048;
pub const FNDELAY: u32 = 2048;
pub const __POSIX_FADV_DONTNEED: u32 = 4;
pub const __POSIX_FADV_NOREUSE: u32 = 5;
pub const POSIX_FADV_NORMAL: u32 = 0;
pub const POSIX_FADV_RANDOM: u32 = 1;
pub const POSIX_FADV_SEQUENTIAL: u32 = 2;
pub const POSIX_FADV_WILLNEED: u32 = 3;
pub const POSIX_FADV_DONTNEED: u32 = 4;
pub const POSIX_FADV_NOREUSE: u32 = 5;
pub const AT_FDCWD: i32 = -100;
pub const AT_SYMLINK_NOFOLLOW: u32 = 256;
pub const AT_REMOVEDIR: u32 = 512;
pub const AT_SYMLINK_FOLLOW: u32 = 1024;
pub const AT_EACCESS: u32 = 512;
pub const __timespec_defined: u32 = 1;
pub const _BITS_STAT_H: u32 = 1;
pub const _STAT_VER_KERNEL: u32 = 0;
pub const _STAT_VER_LINUX: u32 = 1;
pub const _MKNOD_VER_LINUX: u32 = 0;
pub const _STAT_VER: u32 = 1;
pub const __S_IFMT: u32 = 61440;
pub const __S_IFDIR: u32 = 16384;
pub const __S_IFCHR: u32 = 8192;
pub const __S_IFBLK: u32 = 24576;
pub const __S_IFREG: u32 = 32768;
pub const __S_IFIFO: u32 = 4096;
pub const __S_IFLNK: u32 = 40960;
pub const __S_IFSOCK: u32 = 49152;
pub const __S_ISUID: u32 = 2048;
pub const __S_ISGID: u32 = 1024;
pub const __S_ISVTX: u32 = 512;
pub const __S_IREAD: u32 = 256;
pub const __S_IWRITE: u32 = 128;
pub const __S_IEXEC: u32 = 64;
pub const UTIME_NOW: u32 = 1073741823;
pub const UTIME_OMIT: u32 = 1073741822;
pub const S_IFMT: u32 = 61440;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFIFO: u32 = 4096;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXU: u32 = 448;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXG: u32 = 56;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_IRWXO: u32 = 7;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCKS_PER_SEC: u32 = 1000000;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _XLOCALE_H: u32 = 1;
pub const EINTERNAL: u32 = 255;
pub const ELASTIC_BYTE_BUFFER_POOL_CLASS: &'static [u8; 43usize] =
    b"org/apache/hadoop/io/ElasticByteBufferPool\0";
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flock {
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
    pub l_start: __off_t,
    pub l_len: __off_t,
    pub l_pid: __pid_t,
}
#[test]
fn bindgen_test_layout_flock() {
    assert_eq!(
        ::std::mem::size_of::<flock>(),
        32usize,
        concat!("Size of: ", stringify!(flock))
    );
    assert_eq!(
        ::std::mem::align_of::<flock>(),
        8usize,
        concat!("Alignment of ", stringify!(flock))
    );
}
pub type mode_t = __mode_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: ::std::os::raw::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
#[test]
fn bindgen_test_layout_stat() {
    assert_eq!(
        ::std::mem::size_of::<stat>(),
        144usize,
        concat!("Size of: ", stringify!(stat))
    );
    assert_eq!(
        ::std::mem::align_of::<stat>(),
        8usize,
        concat!("Alignment of ", stringify!(stat))
    );
}
extern "C" {
    pub fn fcntl(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn open(
        __file: *const ::std::os::raw::c_char,
        __oflag: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn openat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __oflag: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn creat(__file: *const ::std::os::raw::c_char, __mode: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lockf(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __len: off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_fadvise(
        __fd: ::std::os::raw::c_int,
        __offset: off_t,
        __len: off_t,
        __advise: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_fallocate(
        __fd: ::std::os::raw::c_int,
        __offset: off_t,
        __len: off_t,
    ) -> ::std::os::raw::c_int;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> size_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: __locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
#[doc = " Some utility decls used in libhdfs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hdfsBuilder {
    _unused: [u8; 0],
}
pub type tSize = i32;
#[doc = " size of data for read/write io ops"]
pub type tTime = time_t;
#[doc = " time type in seconds"]
pub type tOffset = i64;
#[doc = " offset within the file"]
pub type tPort = u16;
pub const tObjectKind_kObjectKindFile: tObjectKind = 70;
pub const tObjectKind_kObjectKindDirectory: tObjectKind = 68;
#[doc = " port"]
pub type tObjectKind = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hdfsStreamBuilder {
    _unused: [u8; 0],
}
#[doc = " The C reflection of org.apache.org.hadoop.FileSystem ."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hdfs_internal {
    _unused: [u8; 0],
}
pub type hdfsFS = *mut hdfs_internal;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hdfsFile_internal {
    _unused: [u8; 0],
}
pub type hdfsFile = *mut hdfsFile_internal;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hadoopRzOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hadoopRzBuffer {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Determine if a file is open for read."]
    #[doc = ""]
    #[doc = " @param file     The HDFS file"]
    #[doc = " @return         1 if the file is open for read; 0 otherwise"]
    pub fn hdfsFileIsOpenForRead(file: hdfsFile) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Determine if a file is open for write."]
    #[doc = ""]
    #[doc = " @param file     The HDFS file"]
    #[doc = " @return         1 if the file is open for write; 0 otherwise"]
    pub fn hdfsFileIsOpenForWrite(file: hdfsFile) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hdfsReadStatistics {
    pub totalBytesRead: u64,
    pub totalLocalBytesRead: u64,
    pub totalShortCircuitBytesRead: u64,
    pub totalZeroCopyBytesRead: u64,
}
#[test]
fn bindgen_test_layout_hdfsReadStatistics() {
    assert_eq!(
        ::std::mem::size_of::<hdfsReadStatistics>(),
        32usize,
        concat!("Size of: ", stringify!(hdfsReadStatistics))
    );
    assert_eq!(
        ::std::mem::align_of::<hdfsReadStatistics>(),
        8usize,
        concat!("Alignment of ", stringify!(hdfsReadStatistics))
    );
}
extern "C" {
    #[doc = " Get read statistics about a file.  This is only applicable to files"]
    #[doc = " opened for reading."]
    #[doc = ""]
    #[doc = " @param file     The HDFS file"]
    #[doc = " @param stats    (out parameter) on a successful return, the read"]
    #[doc = "                 statistics.  Unchanged otherwise.  You must free the"]
    #[doc = "                 returned statistics with hdfsFileFreeReadStatistics."]
    #[doc = " @return         0 if the statistics were successfully returned,"]
    #[doc = "                 -1 otherwise.  On a failure, please check errno against"]
    #[doc = "                 ENOTSUP.  webhdfs, LocalFilesystem, and so forth may"]
    #[doc = "                 not support read statistics."]
    pub fn hdfsFileGetReadStatistics(
        file: hdfsFile,
        stats: *mut *mut hdfsReadStatistics,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param stats    HDFS read statistics for a file."]
    #[doc = ""]
    #[doc = " @return the number of remote bytes read."]
    pub fn hdfsReadStatisticsGetRemoteBytesRead(stats: *const hdfsReadStatistics) -> i64;
}
extern "C" {
    #[doc = " Clear the read statistics for a file."]
    #[doc = ""]
    #[doc = " @param file      The file to clear the read statistics of."]
    #[doc = ""]
    #[doc = " @return          0 on success; the error code otherwise."]
    #[doc = "                  EINVAL: the file is not open for reading."]
    #[doc = "                  ENOTSUP: the file does not support clearing the read"]
    #[doc = "                  statistics."]
    #[doc = "                  Errno will also be set to this code on failure."]
    pub fn hdfsFileClearReadStatistics(file: hdfsFile) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free some HDFS read statistics."]
    #[doc = ""]
    #[doc = " @param stats    The HDFS read statistics to free."]
    pub fn hdfsFileFreeReadStatistics(stats: *mut hdfsReadStatistics);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hdfsHedgedReadMetrics {
    pub hedgedReadOps: u64,
    pub hedgedReadOpsWin: u64,
    pub hedgedReadOpsInCurThread: u64,
}
#[test]
fn bindgen_test_layout_hdfsHedgedReadMetrics() {
    assert_eq!(
        ::std::mem::size_of::<hdfsHedgedReadMetrics>(),
        24usize,
        concat!("Size of: ", stringify!(hdfsHedgedReadMetrics))
    );
    assert_eq!(
        ::std::mem::align_of::<hdfsHedgedReadMetrics>(),
        8usize,
        concat!("Alignment of ", stringify!(hdfsHedgedReadMetrics))
    );
}
extern "C" {
    #[doc = " Get cluster wide hedged read metrics."]
    #[doc = ""]
    #[doc = " @param fs       The configured filesystem handle"]
    #[doc = " @param metrics  (out parameter) on a successful return, the hedged read"]
    #[doc = "                 metrics. Unchanged otherwise. You must free the returned"]
    #[doc = "                 statistics with hdfsFreeHedgedReadMetrics."]
    #[doc = " @return         0 if the metrics were successfully returned, -1 otherwise."]
    #[doc = "                 On a failure, please check errno against"]
    #[doc = "                 ENOTSUP. webhdfs, LocalFilesystem, and so forth may"]
    #[doc = "                 not support hedged read metrics."]
    pub fn hdfsGetHedgedReadMetrics(
        fs: hdfsFS,
        metrics: *mut *mut hdfsHedgedReadMetrics,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free HDFS Hedged read metrics."]
    #[doc = ""]
    #[doc = " @param metrics  The HDFS Hedged read metrics to free"]
    pub fn hdfsFreeHedgedReadMetrics(metrics: *mut hdfsHedgedReadMetrics);
}
extern "C" {
    #[doc = " hdfsConnectAsUser - Connect to a hdfs file system as a specific user"]
    #[doc = " Connect to the hdfs."]
    #[doc = " @param nn   The NameNode.  See hdfsBuilderSetNameNode for details."]
    #[doc = " @param port The port on which the server is listening."]
    #[doc = " @param user the user name (this is hadoop domain user). Or NULL is equivelant to hhdfsConnect(host, port)"]
    #[doc = " @return Returns a handle to the filesystem or NULL on error."]
    #[doc = " @deprecated Use hdfsBuilderConnect instead."]
    pub fn hdfsConnectAsUser(
        nn: *const ::std::os::raw::c_char,
        port: tPort,
        user: *const ::std::os::raw::c_char,
    ) -> hdfsFS;
}
extern "C" {
    #[doc = " hdfsConnect - Connect to a hdfs file system."]
    #[doc = " Connect to the hdfs."]
    #[doc = " @param nn   The NameNode.  See hdfsBuilderSetNameNode for details."]
    #[doc = " @param port The port on which the server is listening."]
    #[doc = " @return Returns a handle to the filesystem or NULL on error."]
    #[doc = " @deprecated Use hdfsBuilderConnect instead."]
    pub fn hdfsConnect(nn: *const ::std::os::raw::c_char, port: tPort) -> hdfsFS;
}
extern "C" {
    #[doc = " hdfsConnect - Connect to an hdfs file system."]
    #[doc = ""]
    #[doc = " Forces a new instance to be created"]
    #[doc = ""]
    #[doc = " @param nn     The NameNode.  See hdfsBuilderSetNameNode for details."]
    #[doc = " @param port   The port on which the server is listening."]
    #[doc = " @param user   The user name to use when connecting"]
    #[doc = " @return       Returns a handle to the filesystem or NULL on error."]
    #[doc = " @deprecated   Use hdfsBuilderConnect instead."]
    pub fn hdfsConnectAsUserNewInstance(
        nn: *const ::std::os::raw::c_char,
        port: tPort,
        user: *const ::std::os::raw::c_char,
    ) -> hdfsFS;
}
extern "C" {
    #[doc = " hdfsConnect - Connect to an hdfs file system."]
    #[doc = ""]
    #[doc = " Forces a new instance to be created"]
    #[doc = ""]
    #[doc = " @param nn     The NameNode.  See hdfsBuilderSetNameNode for details."]
    #[doc = " @param port   The port on which the server is listening."]
    #[doc = " @return       Returns a handle to the filesystem or NULL on error."]
    #[doc = " @deprecated   Use hdfsBuilderConnect instead."]
    pub fn hdfsConnectNewInstance(nn: *const ::std::os::raw::c_char, port: tPort) -> hdfsFS;
}
extern "C" {
    #[doc = " Connect to HDFS using the parameters defined by the builder."]
    #[doc = ""]
    #[doc = " The HDFS builder will be freed, whether or not the connection was"]
    #[doc = " successful."]
    #[doc = ""]
    #[doc = " Every successful call to hdfsBuilderConnect should be matched with a call"]
    #[doc = " to hdfsDisconnect, when the hdfsFS is no longer needed."]
    #[doc = ""]
    #[doc = " @param bld    The HDFS builder"]
    #[doc = " @return       Returns a handle to the filesystem, or NULL on error."]
    pub fn hdfsBuilderConnect(bld: *mut hdfsBuilder) -> hdfsFS;
}
extern "C" {
    #[doc = " Create an HDFS builder."]
    #[doc = ""]
    #[doc = " @return The HDFS builder, or NULL on error."]
    pub fn hdfsNewBuilder() -> *mut hdfsBuilder;
}
extern "C" {
    #[doc = " Force the builder to always create a new instance of the FileSystem,"]
    #[doc = " rather than possibly finding one in the cache."]
    #[doc = ""]
    #[doc = " @param bld The HDFS builder"]
    pub fn hdfsBuilderSetForceNewInstance(bld: *mut hdfsBuilder);
}
extern "C" {
    #[doc = " Set the HDFS NameNode to connect to."]
    #[doc = ""]
    #[doc = " @param bld  The HDFS builder"]
    #[doc = " @param nn   The NameNode to use."]
    #[doc = ""]
    #[doc = "             If the string given is 'default', the default NameNode"]
    #[doc = "             configuration will be used (from the XML configuration files)"]
    #[doc = ""]
    #[doc = "             If NULL is given, a LocalFileSystem will be created."]
    #[doc = ""]
    #[doc = "             If the string starts with a protocol type such as file:// or"]
    #[doc = "             hdfs://, this protocol type will be used.  If not, the"]
    #[doc = "             hdfs:// protocol type will be used."]
    #[doc = ""]
    #[doc = "             You may specify a NameNode port in the usual way by"]
    #[doc = "             passing a string of the format hdfs://<hostname>:<port>."]
    #[doc = "             Alternately, you may set the port with"]
    #[doc = "             hdfsBuilderSetNameNodePort.  However, you must not pass the"]
    #[doc = "             port in two different ways."]
    pub fn hdfsBuilderSetNameNode(bld: *mut hdfsBuilder, nn: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Set the port of the HDFS NameNode to connect to."]
    #[doc = ""]
    #[doc = " @param bld The HDFS builder"]
    #[doc = " @param port The port."]
    pub fn hdfsBuilderSetNameNodePort(bld: *mut hdfsBuilder, port: tPort);
}
extern "C" {
    #[doc = " Set the username to use when connecting to the HDFS cluster."]
    #[doc = ""]
    #[doc = " @param bld The HDFS builder"]
    #[doc = " @param userName The user name.  The string will be shallow-copied."]
    pub fn hdfsBuilderSetUserName(bld: *mut hdfsBuilder, userName: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Set the path to the Kerberos ticket cache to use when connecting to"]
    #[doc = " the HDFS cluster."]
    #[doc = ""]
    #[doc = " @param bld The HDFS builder"]
    #[doc = " @param kerbTicketCachePath The Kerberos ticket cache path.  The string"]
    #[doc = "                            will be shallow-copied."]
    pub fn hdfsBuilderSetKerbTicketCachePath(
        bld: *mut hdfsBuilder,
        kerbTicketCachePath: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Free an HDFS builder."]
    #[doc = ""]
    #[doc = " It is normally not necessary to call this function since"]
    #[doc = " hdfsBuilderConnect frees the builder."]
    #[doc = ""]
    #[doc = " @param bld The HDFS builder"]
    pub fn hdfsFreeBuilder(bld: *mut hdfsBuilder);
}
extern "C" {
    #[doc = " Set a configuration string for an HdfsBuilder."]
    #[doc = ""]
    #[doc = " @param key      The key to set."]
    #[doc = " @param val      The value, or NULL to set no value."]
    #[doc = "                 This will be shallow-copied.  You are responsible for"]
    #[doc = "                 ensuring that it remains valid until the builder is"]
    #[doc = "                 freed."]
    #[doc = ""]
    #[doc = " @return         0 on success; nonzero error code otherwise."]
    pub fn hdfsBuilderConfSetStr(
        bld: *mut hdfsBuilder,
        key: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a configuration string."]
    #[doc = ""]
    #[doc = " @param key      The key to find"]
    #[doc = " @param val      (out param) The value.  This will be set to NULL if the"]
    #[doc = "                 key isn't found.  You must free this string with"]
    #[doc = "                 hdfsConfStrFree."]
    #[doc = ""]
    #[doc = " @return         0 on success; nonzero error code otherwise."]
    #[doc = "                 Failure to find the key is not an error."]
    pub fn hdfsConfGetStr(
        key: *const ::std::os::raw::c_char,
        val: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a configuration integer."]
    #[doc = ""]
    #[doc = " @param key      The key to find"]
    #[doc = " @param val      (out param) The value.  This will NOT be changed if the"]
    #[doc = "                 key isn't found."]
    #[doc = ""]
    #[doc = " @return         0 on success; nonzero error code otherwise."]
    #[doc = "                 Failure to find the key is not an error."]
    pub fn hdfsConfGetInt(
        key: *const ::std::os::raw::c_char,
        val: *mut i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free a configuration string found with hdfsConfGetStr."]
    #[doc = ""]
    #[doc = " @param val      A configuration string obtained from hdfsConfGetStr"]
    pub fn hdfsConfStrFree(val: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " hdfsDisconnect - Disconnect from the hdfs file system."]
    #[doc = " Disconnect from hdfs."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @return Returns 0 on success, -1 on error."]
    #[doc = "         Even if there is an error, the resources associated with the"]
    #[doc = "         hdfsFS will be freed."]
    pub fn hdfsDisconnect(fs: hdfsFS) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsOpenFile - Open a hdfs file in given mode."]
    #[doc = " @deprecated    Use the hdfsStreamBuilder functions instead."]
    #[doc = " This function does not support setting block sizes bigger than 2 GB."]
    #[doc = ""]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param path The full path to the file."]
    #[doc = " @param flags - an | of bits/fcntl.h file flags - supported flags are O_RDONLY, O_WRONLY (meaning create or overwrite i.e., implies O_TRUNCAT),"]
    #[doc = " O_WRONLY|O_APPEND. Other flags are generally ignored other than (O_RDWR || (O_EXCL & O_CREAT)) which return NULL and set errno equal ENOTSUP."]
    #[doc = " @param bufferSize Size of buffer for read/write - pass 0 if you want"]
    #[doc = " to use the default configured values."]
    #[doc = " @param replication Block replication - pass 0 if you want to use"]
    #[doc = " the default configured values."]
    #[doc = " @param blocksize Size of block - pass 0 if you want to use the"]
    #[doc = " default configured values.  Note that if you want a block size bigger"]
    #[doc = " than 2 GB, you must use the hdfsStreamBuilder API rather than this"]
    #[doc = " deprecated function."]
    #[doc = " @return Returns the handle to the open file or NULL on error."]
    pub fn hdfsOpenFile(
        fs: hdfsFS,
        path: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        bufferSize: ::std::os::raw::c_int,
        replication: ::std::os::raw::c_short,
        blocksize: tSize,
    ) -> hdfsFile;
}
extern "C" {
    #[doc = " hdfsStreamBuilderAlloc - Allocate an HDFS stream builder."]
    #[doc = ""]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param path The full path to the file.  Will be deep-copied."]
    #[doc = " @param flags The open flags, as in hdfsOpenFile."]
    #[doc = " @return Returns the hdfsStreamBuilder, or NULL on error."]
    pub fn hdfsStreamBuilderAlloc(
        fs: hdfsFS,
        path: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> *mut hdfsStreamBuilder;
}
extern "C" {
    #[doc = " hdfsStreamBuilderFree - Free an HDFS file builder."]
    #[doc = ""]
    #[doc = " It is normally not necessary to call this function since"]
    #[doc = " hdfsStreamBuilderBuild frees the builder."]
    #[doc = ""]
    #[doc = " @param bld The hdfsStreamBuilder to free."]
    pub fn hdfsStreamBuilderFree(bld: *mut hdfsStreamBuilder);
}
extern "C" {
    #[doc = " hdfsStreamBuilderSetBufferSize - Set the stream buffer size."]
    #[doc = ""]
    #[doc = " @param bld The hdfs stream builder."]
    #[doc = " @param bufferSize The buffer size to set."]
    #[doc = ""]
    #[doc = " @return 0 on success, or -1 on error.  Errno will be set on error."]
    pub fn hdfsStreamBuilderSetBufferSize(
        bld: *mut hdfsStreamBuilder,
        bufferSize: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsStreamBuilderSetReplication - Set the replication for the stream."]
    #[doc = " This is only relevant for output streams, which will create new blocks."]
    #[doc = ""]
    #[doc = " @param bld The hdfs stream builder."]
    #[doc = " @param replication The replication to set."]
    #[doc = ""]
    #[doc = " @return 0 on success, or -1 on error.  Errno will be set on error."]
    #[doc = "              If you call this on an input stream builder, you will get"]
    #[doc = "              EINVAL, because this configuration is not relevant to input"]
    #[doc = "              streams."]
    pub fn hdfsStreamBuilderSetReplication(
        bld: *mut hdfsStreamBuilder,
        replication: i16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsStreamBuilderSetDefaultBlockSize - Set the default block size for"]
    #[doc = " the stream.  This is only relevant for output streams, which will create"]
    #[doc = " new blocks."]
    #[doc = ""]
    #[doc = " @param bld The hdfs stream builder."]
    #[doc = " @param defaultBlockSize The default block size to set."]
    #[doc = ""]
    #[doc = " @return 0 on success, or -1 on error.  Errno will be set on error."]
    #[doc = "              If you call this on an input stream builder, you will get"]
    #[doc = "              EINVAL, because this configuration is not relevant to input"]
    #[doc = "              streams."]
    pub fn hdfsStreamBuilderSetDefaultBlockSize(
        bld: *mut hdfsStreamBuilder,
        defaultBlockSize: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsStreamBuilderBuild - Build the stream by calling open or create."]
    #[doc = ""]
    #[doc = " @param bld The hdfs stream builder.  This pointer will be freed, whether"]
    #[doc = "            or not the open succeeds."]
    #[doc = ""]
    #[doc = " @return the stream pointer on success, or NULL on error.  Errno will be"]
    #[doc = " set on error."]
    pub fn hdfsStreamBuilderBuild(bld: *mut hdfsStreamBuilder) -> hdfsFile;
}
extern "C" {
    #[doc = " hdfsTruncateFile - Truncate a hdfs file to given lenght."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param path The full path to the file."]
    #[doc = " @param newlength The size the file is to be truncated to"]
    #[doc = " @return 1 if the file has been truncated to the desired newlength"]
    #[doc = "         and is immediately available to be reused for write operations"]
    #[doc = "         such as append."]
    #[doc = "         0 if a background process of adjusting the length of the last"]
    #[doc = "         block has been started, and clients should wait for it to"]
    #[doc = "         complete before proceeding with further file updates."]
    #[doc = "         -1 on error."]
    pub fn hdfsTruncateFile(
        fs: hdfsFS,
        path: *const ::std::os::raw::c_char,
        newlength: tOffset,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsUnbufferFile - Reduce the buffering done on a file."]
    #[doc = ""]
    #[doc = " @param file  The file to unbuffer."]
    #[doc = " @return      0 on success"]
    #[doc = "              ENOTSUP if the file does not support unbuffering"]
    #[doc = "              Errno will also be set to this value."]
    pub fn hdfsUnbufferFile(file: hdfsFile) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsCloseFile - Close an open file."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param file The file handle."]
    #[doc = " @return Returns 0 on success, -1 on error."]
    #[doc = "         On error, errno will be set appropriately."]
    #[doc = "         If the hdfs file was valid, the memory associated with it will"]
    #[doc = "         be freed at the end of this call, even if there was an I/O"]
    #[doc = "         error."]
    pub fn hdfsCloseFile(fs: hdfsFS, file: hdfsFile) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsExists - Checks if a given path exsits on the filesystem"]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param path The path to look for"]
    #[doc = " @return Returns 0 on success, -1 on error."]
    pub fn hdfsExists(fs: hdfsFS, path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsSeek - Seek to given offset in file."]
    #[doc = " This works only for files opened in read-only mode."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param file The file handle."]
    #[doc = " @param desiredPos Offset into the file to seek into."]
    #[doc = " @return Returns 0 on success, -1 on error."]
    pub fn hdfsSeek(fs: hdfsFS, file: hdfsFile, desiredPos: tOffset) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsTell - Get the current offset in the file, in bytes."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param file The file handle."]
    #[doc = " @return Current offset, -1 on error."]
    pub fn hdfsTell(fs: hdfsFS, file: hdfsFile) -> tOffset;
}
extern "C" {
    #[doc = " hdfsRead - Read data from an open file."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param file The file handle."]
    #[doc = " @param buffer The buffer to copy read bytes into."]
    #[doc = " @param length The length of the buffer."]
    #[doc = " @return      On success, a positive number indicating how many bytes"]
    #[doc = "              were read."]
    #[doc = "              On end-of-file, 0."]
    #[doc = "              On error, -1.  Errno will be set to the error code."]
    #[doc = "              Just like the POSIX read function, hdfsRead will return -1"]
    #[doc = "              and set errno to EINTR if data is temporarily unavailable,"]
    #[doc = "              but we are not yet at the end of the file."]
    pub fn hdfsRead(
        fs: hdfsFS,
        file: hdfsFile,
        buffer: *mut ::std::os::raw::c_void,
        length: tSize,
    ) -> tSize;
}
extern "C" {
    #[doc = " hdfsPread - Positional read of data from an open file."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param file The file handle."]
    #[doc = " @param position Position from which to read"]
    #[doc = " @param buffer The buffer to copy read bytes into."]
    #[doc = " @param length The length of the buffer."]
    #[doc = " @return      See hdfsRead"]
    pub fn hdfsPread(
        fs: hdfsFS,
        file: hdfsFile,
        position: tOffset,
        buffer: *mut ::std::os::raw::c_void,
        length: tSize,
    ) -> tSize;
}
extern "C" {
    #[doc = " hdfsWrite - Write data into an open file."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param file The file handle."]
    #[doc = " @param buffer The data."]
    #[doc = " @param length The no. of bytes to write."]
    #[doc = " @return Returns the number of bytes written, -1 on error."]
    pub fn hdfsWrite(
        fs: hdfsFS,
        file: hdfsFile,
        buffer: *const ::std::os::raw::c_void,
        length: tSize,
    ) -> tSize;
}
extern "C" {
    #[doc = " hdfsWrite - Flush the data."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param file The file handle."]
    #[doc = " @return Returns 0 on success, -1 on error."]
    pub fn hdfsFlush(fs: hdfsFS, file: hdfsFile) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsHFlush - Flush out the data in client's user buffer. After the"]
    #[doc = " return of this call, new readers will see the data."]
    #[doc = " @param fs configured filesystem handle"]
    #[doc = " @param file file handle"]
    #[doc = " @return 0 on success, -1 on error and sets errno"]
    pub fn hdfsHFlush(fs: hdfsFS, file: hdfsFile) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsHSync - Similar to posix fsync, Flush out the data in client's"]
    #[doc = " user buffer. all the way to the disk device (but the disk may have"]
    #[doc = " it in its cache)."]
    #[doc = " @param fs configured filesystem handle"]
    #[doc = " @param file file handle"]
    #[doc = " @return 0 on success, -1 on error and sets errno"]
    pub fn hdfsHSync(fs: hdfsFS, file: hdfsFile) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsAvailable - Number of bytes that can be read from this"]
    #[doc = " input stream without blocking."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param file The file handle."]
    #[doc = " @return Returns available bytes; -1 on error."]
    pub fn hdfsAvailable(fs: hdfsFS, file: hdfsFile) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsCopy - Copy file from one filesystem to another."]
    #[doc = " @param srcFS The handle to source filesystem."]
    #[doc = " @param src The path of source file."]
    #[doc = " @param dstFS The handle to destination filesystem."]
    #[doc = " @param dst The path of destination file."]
    #[doc = " @return Returns 0 on success, -1 on error."]
    pub fn hdfsCopy(
        srcFS: hdfsFS,
        src: *const ::std::os::raw::c_char,
        dstFS: hdfsFS,
        dst: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsMove - Move file from one filesystem to another."]
    #[doc = " @param srcFS The handle to source filesystem."]
    #[doc = " @param src The path of source file."]
    #[doc = " @param dstFS The handle to destination filesystem."]
    #[doc = " @param dst The path of destination file."]
    #[doc = " @return Returns 0 on success, -1 on error."]
    pub fn hdfsMove(
        srcFS: hdfsFS,
        src: *const ::std::os::raw::c_char,
        dstFS: hdfsFS,
        dst: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsDelete - Delete file."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param path The path of the file."]
    #[doc = " @param recursive if path is a directory and set to"]
    #[doc = " non-zero, the directory is deleted else throws an exception. In"]
    #[doc = " case of a file the recursive argument is irrelevant."]
    #[doc = " @return Returns 0 on success, -1 on error."]
    pub fn hdfsDelete(
        fs: hdfsFS,
        path: *const ::std::os::raw::c_char,
        recursive: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsRename - Rename file."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param oldPath The path of the source file."]
    #[doc = " @param newPath The path of the destination file."]
    #[doc = " @return Returns 0 on success, -1 on error."]
    pub fn hdfsRename(
        fs: hdfsFS,
        oldPath: *const ::std::os::raw::c_char,
        newPath: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsGetWorkingDirectory - Get the current working directory for"]
    #[doc = " the given filesystem."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param buffer The user-buffer to copy path of cwd into."]
    #[doc = " @param bufferSize The length of user-buffer."]
    #[doc = " @return Returns buffer, NULL on error."]
    pub fn hdfsGetWorkingDirectory(
        fs: hdfsFS,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " hdfsSetWorkingDirectory - Set the working directory. All relative"]
    #[doc = " paths will be resolved relative to it."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param path The path of the new 'cwd'."]
    #[doc = " @return Returns 0 on success, -1 on error."]
    pub fn hdfsSetWorkingDirectory(
        fs: hdfsFS,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsCreateDirectory - Make the given file and all non-existent"]
    #[doc = " parents into directories."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param path The path of the directory."]
    #[doc = " @return Returns 0 on success, -1 on error."]
    pub fn hdfsCreateDirectory(
        fs: hdfsFS,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsSetReplication - Set the replication of the specified"]
    #[doc = " file to the supplied value"]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param path The path of the file."]
    #[doc = " @return Returns 0 on success, -1 on error."]
    pub fn hdfsSetReplication(
        fs: hdfsFS,
        path: *const ::std::os::raw::c_char,
        replication: i16,
    ) -> ::std::os::raw::c_int;
}
#[doc = " hdfsFileInfo - Information about a file/directory."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hdfsFileInfo {
    pub mKind: tObjectKind,
    pub mName: *mut ::std::os::raw::c_char,
    pub mLastMod: tTime,
    pub mSize: tOffset,
    pub mReplication: ::std::os::raw::c_short,
    pub mBlockSize: tOffset,
    pub mOwner: *mut ::std::os::raw::c_char,
    pub mGroup: *mut ::std::os::raw::c_char,
    pub mPermissions: ::std::os::raw::c_short,
    pub mLastAccess: tTime,
}
#[test]
fn bindgen_test_layout_hdfsFileInfo() {
    assert_eq!(
        ::std::mem::size_of::<hdfsFileInfo>(),
        80usize,
        concat!("Size of: ", stringify!(hdfsFileInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<hdfsFileInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(hdfsFileInfo))
    );
}
extern "C" {
    #[doc = " hdfsListDirectory - Get list of files/directories for a given"]
    #[doc = " directory-path. hdfsFreeFileInfo should be called to deallocate memory."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param path The path of the directory."]
    #[doc = " @param numEntries Set to the number of files/directories in path."]
    #[doc = " @return Returns a dynamically-allocated array of hdfsFileInfo"]
    #[doc = " objects; NULL on error or empty directory."]
    #[doc = " errno is set to non-zero on error or zero on success."]
    pub fn hdfsListDirectory(
        fs: hdfsFS,
        path: *const ::std::os::raw::c_char,
        numEntries: *mut ::std::os::raw::c_int,
    ) -> *mut hdfsFileInfo;
}
extern "C" {
    #[doc = " hdfsGetPathInfo - Get information about a path as a (dynamically"]
    #[doc = " allocated) single hdfsFileInfo struct. hdfsFreeFileInfo should be"]
    #[doc = " called when the pointer is no longer needed."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param path The path of the file."]
    #[doc = " @return Returns a dynamically-allocated hdfsFileInfo object;"]
    #[doc = " NULL on error."]
    pub fn hdfsGetPathInfo(fs: hdfsFS, path: *const ::std::os::raw::c_char) -> *mut hdfsFileInfo;
}
extern "C" {
    #[doc = " hdfsFreeFileInfo - Free up the hdfsFileInfo array (including fields)"]
    #[doc = " @param hdfsFileInfo The array of dynamically-allocated hdfsFileInfo"]
    #[doc = " objects."]
    #[doc = " @param numEntries The size of the array."]
    pub fn hdfsFreeFileInfo(hdfsFileInfo: *mut hdfsFileInfo, numEntries: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " hdfsFileIsEncrypted: determine if a file is encrypted based on its"]
    #[doc = " hdfsFileInfo."]
    #[doc = " @return -1 if there was an error (errno will be set), 0 if the file is"]
    #[doc = "         not encrypted, 1 if the file is encrypted."]
    pub fn hdfsFileIsEncrypted(hdfsFileInfo: *mut hdfsFileInfo) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsGetHosts - Get hostnames where a particular block (determined by"]
    #[doc = " pos & blocksize) of a file is stored. The last element in the array"]
    #[doc = " is NULL. Due to replication, a single block could be present on"]
    #[doc = " multiple hosts."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param path The path of the file."]
    #[doc = " @param start The start of the block."]
    #[doc = " @param length The length of the block."]
    #[doc = " @return Returns a dynamically-allocated 2-d array of blocks-hosts;"]
    #[doc = " NULL on error."]
    pub fn hdfsGetHosts(
        fs: hdfsFS,
        path: *const ::std::os::raw::c_char,
        start: tOffset,
        length: tOffset,
    ) -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " hdfsFreeHosts - Free up the structure returned by hdfsGetHosts"]
    #[doc = " @param hdfsFileInfo The array of dynamically-allocated hdfsFileInfo"]
    #[doc = " objects."]
    #[doc = " @param numEntries The size of the array."]
    pub fn hdfsFreeHosts(blockHosts: *mut *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " hdfsGetDefaultBlockSize - Get the default blocksize."]
    #[doc = ""]
    #[doc = " @param fs            The configured filesystem handle."]
    #[doc = " @deprecated          Use hdfsGetDefaultBlockSizeAtPath instead."]
    #[doc = ""]
    #[doc = " @return              Returns the default blocksize, or -1 on error."]
    pub fn hdfsGetDefaultBlockSize(fs: hdfsFS) -> tOffset;
}
extern "C" {
    #[doc = " hdfsGetDefaultBlockSizeAtPath - Get the default blocksize at the"]
    #[doc = " filesystem indicated by a given path."]
    #[doc = ""]
    #[doc = " @param fs            The configured filesystem handle."]
    #[doc = " @param path          The given path will be used to locate the actual"]
    #[doc = "                      filesystem.  The full path does not have to exist."]
    #[doc = ""]
    #[doc = " @return              Returns the default blocksize, or -1 on error."]
    pub fn hdfsGetDefaultBlockSizeAtPath(
        fs: hdfsFS,
        path: *const ::std::os::raw::c_char,
    ) -> tOffset;
}
extern "C" {
    #[doc = " hdfsGetCapacity - Return the raw capacity of the filesystem."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @return Returns the raw-capacity; -1 on error."]
    pub fn hdfsGetCapacity(fs: hdfsFS) -> tOffset;
}
extern "C" {
    #[doc = " hdfsGetUsed - Return the total raw size of all files in the filesystem."]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @return Returns the total-size; -1 on error."]
    pub fn hdfsGetUsed(fs: hdfsFS) -> tOffset;
}
extern "C" {
    #[doc = " Change the user and/or group of a file or directory."]
    #[doc = ""]
    #[doc = " @param fs            The configured filesystem handle."]
    #[doc = " @param path          the path to the file or directory"]
    #[doc = " @param owner         User string.  Set to NULL for 'no change'"]
    #[doc = " @param group         Group string.  Set to NULL for 'no change'"]
    #[doc = " @return              0 on success else -1"]
    pub fn hdfsChown(
        fs: hdfsFS,
        path: *const ::std::os::raw::c_char,
        owner: *const ::std::os::raw::c_char,
        group: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsChmod"]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param path the path to the file or directory"]
    #[doc = " @param mode the bitmask to set it to"]
    #[doc = " @return 0 on success else -1"]
    pub fn hdfsChmod(
        fs: hdfsFS,
        path: *const ::std::os::raw::c_char,
        mode: ::std::os::raw::c_short,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hdfsUtime"]
    #[doc = " @param fs The configured filesystem handle."]
    #[doc = " @param path the path to the file or directory"]
    #[doc = " @param mtime new modification time or -1 for no change"]
    #[doc = " @param atime new access time or -1 for no change"]
    #[doc = " @return 0 on success else -1"]
    pub fn hdfsUtime(
        fs: hdfsFS,
        path: *const ::std::os::raw::c_char,
        mtime: tTime,
        atime: tTime,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate a zero-copy options structure."]
    #[doc = ""]
    #[doc = " You must free all options structures allocated with this function using"]
    #[doc = " hadoopRzOptionsFree."]
    #[doc = ""]
    #[doc = " @return            A zero-copy options structure, or NULL if one could"]
    #[doc = "                    not be allocated.  If NULL is returned, errno will"]
    #[doc = "                    contain the error number."]
    pub fn hadoopRzOptionsAlloc() -> *mut hadoopRzOptions;
}
extern "C" {
    #[doc = " Determine whether we should skip checksums in read0."]
    #[doc = ""]
    #[doc = " @param opts        The options structure."]
    #[doc = " @param skip        Nonzero to skip checksums sometimes; zero to always"]
    #[doc = "                    check them."]
    #[doc = ""]
    #[doc = " @return            0 on success; -1 plus errno on failure."]
    pub fn hadoopRzOptionsSetSkipChecksum(
        opts: *mut hadoopRzOptions,
        skip: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the ByteBufferPool to use with read0."]
    #[doc = ""]
    #[doc = " @param opts        The options structure."]
    #[doc = " @param className   If this is NULL, we will not use any"]
    #[doc = "                    ByteBufferPool.  If this is non-NULL, it will be"]
    #[doc = "                    treated as the name of the pool class to use."]
    #[doc = "                    For example, you can use"]
    #[doc = "                    ELASTIC_BYTE_BUFFER_POOL_CLASS."]
    #[doc = ""]
    #[doc = " @return            0 if the ByteBufferPool class was found and"]
    #[doc = "                    instantiated;"]
    #[doc = "                    -1 plus errno otherwise."]
    pub fn hadoopRzOptionsSetByteBufferPool(
        opts: *mut hadoopRzOptions,
        className: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free a hadoopRzOptionsFree structure."]
    #[doc = ""]
    #[doc = " @param opts        The options structure to free."]
    #[doc = "                    Any associated ByteBufferPool will also be freed."]
    pub fn hadoopRzOptionsFree(opts: *mut hadoopRzOptions);
}
extern "C" {
    #[doc = " Perform a byte buffer read."]
    #[doc = " If possible, this will be a zero-copy (mmap) read."]
    #[doc = ""]
    #[doc = " @param file       The file to read from."]
    #[doc = " @param opts       An options structure created by hadoopRzOptionsAlloc."]
    #[doc = " @param maxLength  The maximum length to read.  We may read fewer bytes"]
    #[doc = "                   than this length."]
    #[doc = ""]
    #[doc = " @return           On success, we will return a new hadoopRzBuffer."]
    #[doc = "                   This buffer will continue to be valid and readable"]
    #[doc = "                   until it is released by readZeroBufferFree.  Failure to"]
    #[doc = "                   release a buffer will lead to a memory leak."]
    #[doc = "                   You can access the data within the hadoopRzBuffer with"]
    #[doc = "                   hadoopRzBufferGet.  If you have reached EOF, the data"]
    #[doc = "                   within the hadoopRzBuffer will be NULL.  You must still"]
    #[doc = "                   free hadoopRzBuffer instances containing NULL."]
    #[doc = ""]
    #[doc = "                   On failure, we will return NULL plus an errno code."]
    #[doc = "                   errno = EOPNOTSUPP indicates that we could not do a"]
    #[doc = "                   zero-copy read, and there was no ByteBufferPool"]
    #[doc = "                   supplied."]
    pub fn hadoopReadZero(
        file: hdfsFile,
        opts: *mut hadoopRzOptions,
        maxLength: i32,
    ) -> *mut hadoopRzBuffer;
}
extern "C" {
    #[doc = " Determine the length of the buffer returned from readZero."]
    #[doc = ""]
    #[doc = " @param buffer     a buffer returned from readZero."]
    #[doc = " @return           the length of the buffer."]
    pub fn hadoopRzBufferLength(buffer: *const hadoopRzBuffer) -> i32;
}
extern "C" {
    #[doc = " Get a pointer to the raw buffer returned from readZero."]
    #[doc = ""]
    #[doc = " To find out how many bytes this buffer contains, call"]
    #[doc = " hadoopRzBufferLength."]
    #[doc = ""]
    #[doc = " @param buffer     a buffer returned from readZero."]
    #[doc = " @return           a pointer to the start of the buffer.  This will be"]
    #[doc = "                   NULL when end-of-file has been reached."]
    pub fn hadoopRzBufferGet(buffer: *const hadoopRzBuffer) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Release a buffer obtained through readZero."]
    #[doc = ""]
    #[doc = " @param file       The hdfs stream that created this buffer.  This must be"]
    #[doc = "                   the same stream you called hadoopReadZero on."]
    #[doc = " @param buffer     The buffer to release."]
    pub fn hadoopRzBufferFree(file: hdfsFile, buffer: *mut hadoopRzBuffer);
}
extern "C" {
    #[doc = " Get the last exception root cause that happened in the context of the"]
    #[doc = " current thread, i.e. the thread that called into libHDFS."]
    #[doc = ""]
    #[doc = " The pointer returned by this function is guaranteed to be valid until"]
    #[doc = " the next call into libHDFS by the current thread."]
    #[doc = " Users of this function should not free the pointer."]
    #[doc = ""]
    #[doc = " A NULL will be returned if no exception information could be retrieved"]
    #[doc = " for the previous call."]
    #[doc = ""]
    #[doc = " @return           The root cause as a C-string."]
    pub fn hdfsGetLastExceptionRootCause() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the last exception stack trace that happened in the context of the"]
    #[doc = " current thread, i.e. the thread that called into libHDFS."]
    #[doc = ""]
    #[doc = " The pointer returned by this function is guaranteed to be valid until"]
    #[doc = " the next call into libHDFS by the current thread."]
    #[doc = " Users of this function should not free the pointer."]
    #[doc = ""]
    #[doc = " A NULL will be returned if no exception information could be retrieved"]
    #[doc = " for the previous call."]
    #[doc = ""]
    #[doc = " @return           The stack trace as a C-string."]
    pub fn hdfsGetLastExceptionStackTrace() -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
